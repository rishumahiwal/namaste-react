‚ù§Ô∏èWhat is `NPM`?
üëâNPM stands for Node Package Manager, which is a package manager for the JavaScript programming language. It is a command-line tool that allows developers to 
install, manage, and share packages or modules of code written in JavaScript.NPM is used primarily for installing packages required for Node.js, a server-side 
JavaScript runtime environment, but it can also be used for front-end development as well. NPM comes pre-installed with Node.js, which means that when you download
and install Node.js, you also get NPM installed on your system.NPM maintains a large repository of open-source JavaScript packages that can be easily installed 
and used in a project. Developers can use NPM to manage dependencies, which are packages that their project depends on, and NPM can automatically install these 
dependencies for the project.In summary, NPM is a powerful tool that simplifies the process of managing dependencies and sharing code in the JavaScript community.



‚ù§Ô∏èWhat is `Parcel/Webpack`? Why do we need it?
üëâParcel and Webpack are both module bundlers for JavaScript, which means that they take multiple JavaScript files, along with any other related assets, such as stylesheets or images, and combine them into a single file, or a small set of files, that can be served to a web browser. The resulting file is usually optimized for performance, which means that it can be loaded quickly by a web browser, and any unnecessary code can be removed.
Module bundlers like Parcel and Webpack are particularly useful for large-scale web applications that have many separate JavaScript files, as they can help to manage the complexity of such applications by reducing the number of requests the browser needs to make in order to render the application.

Here is a brief overview of Parcel and Webpack:
Parcel is a zero-configuration module bundler for JavaScript that aims to simplify the process of bundling code. It can handle a variety of asset types, including JavaScript, CSS, and images, and automatically optimizes the output. Parcel requires little to no configuration, which makes it a good choice for small to medium-sized projects.
Webpack is a more flexible and configurable module bundler that can handle a wide range of asset types and has a vast ecosystem of plugins and loaders to extend its functionality. Webpack allows developers to customize the bundling process in great detail, which makes it a good choice for larger and more complex projects.



‚ù§Ô∏èWhat is `.parcel-cache?
üëâ.parcel-cache is a directory created by the Parcel bundler during the bundling process. It is used to store cached data about the project's dependencies, which can help to speed up subsequent builds of the project.

When Parcel bundles a project, it analyzes the project's dependencies and generates a cache of metadata about those dependencies. This metadata includes information such as the dependencies' file paths, their sizes, and their modification times. The next time the project is built, Parcel can use this cached metadata to avoid re-analyzing the dependencies, which can save time and improve the speed of the build process.

The .parcel-cache directory is created in the root directory of the project, alongside the node_modules directory. It is generally safe to leave this directory in place, and it will be automatically regenerated by Parcel as needed.

If you need to clear the Parcel cache for any reason, you can simply delete the .parcel-cache directory, and Parcel will regenerate it the next time the project is built. However, keep in mind that deleting the cache may result in a slower build time for the first build after the cache has been cleared, as Parcel will need to re-analyze the project's dependencies.



‚ù§Ô∏èWhat is `npx` ?
üëânpx is a command-line tool that is included with npm since version 5.2.0. It allows developers to run packages or executables from the command line without having to install them globally on their system.

When a package or executable is run using npx, npm will first check whether the package or executable is already installed locally in the project's node_modules directory. If it is not found locally, npx will download and install the package or executable in a temporary directory and run it from there.

npx is particularly useful for running one-off commands or scripts that are not part of a project's regular workflow, or for running packages or executables that the developer does not want to install globally on their system. For example, npx can be used to quickly scaffold a new project using a package like create-react-app, or to run a linter or formatter like eslint or prettier on a single file.

In summary, npx is a command-line tool that allows developers to run packages or executables from the command line without having to install them globally on their system. It is a useful tool for running one-off commands or scripts and for avoiding global installs of packages or executables.



‚ù§Ô∏è What is difference between `dependencies` vs `devDependencies?
üëâIn npm, dependencies and devDependencies are both properties in the package.json file that are used to specify the packages that a project depends on. However, they have different purposes and are used in different contexts.

dependencies refers to the packages that a project requires in order to run in a production environment. These packages are installed when the project is deployed, and are typically essential to the functionality of the project. For example, a web application might have dependencies on packages like express or react, which are required for the application to function.

On the other hand, devDependencies refers to the packages that are only required during the development of the project. These packages are not necessary for the project to run in a production environment, and are typically used for tasks like testing, building, or linting the code. For example, a project might have devDependencies on packages like mocha or babel, which are used for testing and transpiling the code during development.

One important difference between dependencies and devDependencies is that dependencies are installed by default when a package is installed, whereas devDependencies are not. This means that if you want to install the devDependencies for a project, you need to explicitly specify the --dev flag when running npm install.

In summary, dependencies and devDependencies are both used to specify the packages that a project depends on, but dependencies are required for the project to run in a production environment, while devDependencies are only required during development.



‚ù§Ô∏è What is Tree Shaking?
üëâTree shaking is a term used in the context of optimizing the size of JavaScript code in order to improve website or application performance. It refers to the process of eliminating unused or dead code from a project's JavaScript bundle.

During the bundling process, a bundler tool like Webpack or Parcel analyzes a project's code to identify the portions that are actually being used, and removes any code that is not needed. This process is called tree shaking because it involves "shaking" the dependency tree of the project to remove any unused branches or leaves.

Tree shaking is particularly important in projects that use large JavaScript frameworks or libraries, as these often include a lot of code that may not be necessary for a particular application. By removing unused code, the resulting JavaScript bundle can be smaller, and can therefore load faster and consume less memory.

Tree shaking works by analyzing the JavaScript code to identify which functions and variables are actually used, and which ones are not. This requires that the code be written in a certain way, with clear and explicit imports and exports. In addition, some third-party libraries may need to be specifically designed to support tree shaking.

Overall, tree shaking is an important tool for optimizing the performance of JavaScript applications, and it can help to reduce the size of the JavaScript bundle, improve the load time of the website or application, and reduce memory usage.



‚ù§Ô∏èWhat is Hot Module Replacement?
üëâHot Module Replacement (HMR) is a feature of module bundlers, such as Webpack, that enables developers to see the changes they make to their code in real time, without having to manually refresh the browser.

When HMR is enabled, the bundler injects new versions of updated modules into the running application, without requiring a full page reload. This means that any changes made to the code, such as updating a style or modifying a function, are immediately visible in the browser.

HMR works by replacing only the parts of the application that have been changed, rather than reloading the entire application. This can make the development process faster and more efficient, as developers do not have to wait for the entire application to reload each time they make a change. It can also help to preserve the state of the application, such as the values of input fields or the current page scroll position, which can be lost during a full page reload.

To enable HMR, developers need to configure their bundler to support it, and modify their code to take advantage of it. This usually involves adding code to handle updates to the application, such as accepting the updated module and applying the changes to the running code.

Overall, Hot Module Replacement is a powerful feature that can improve the speed and efficiency of the development process, and can make it easier to build and test applications.



‚ù§Ô∏èList down your favourite 5 superpowers of Parcel and describe any 3 of them in your
own words.
üëâAs an AI language model, I don't have personal preferences or opinions, but here are five popular features of Parcel that many developers find helpful:

Zero Configuration: Parcel requires no configuration files or settings, making it easy to set up and use out of the box. This means that developers can quickly start building projects without spending time on configuration.

Fast Builds: Parcel is designed to be fast, with built-in caching and parallel processing to speed up the build process. This means that developers can make changes to their code and see the results quickly, without waiting for the build process to complete.

Automatic Asset Management: Parcel can automatically handle assets like images, fonts, and CSS files, and can optimize them for performance. This means that developers don't need to manually manage their assets or worry about optimization, saving time and effort.

Advanced Code Splitting: Parcel supports advanced code splitting features, allowing developers to split their code into smaller, more manageable chunks. This can improve the performance of the application by reducing the amount of code that needs to be loaded at once.

Flexible Configuration: Although Parcel is designed to work with no configuration, it also allows developers to customize and configure their builds as needed. This gives developers the flexibility to optimize their builds for their specific use case.

Out of these five, here are three features that I can describe in more detail:

Zero Configuration: This feature means that developers don't have to spend time configuring their build system before they can start building their project. This is especially helpful for new developers who may not be familiar with the intricacies of build systems, or for those who just want to get started quickly. With zero configuration, developers can simply install Parcel and start building their project right away.

Fast Builds: The fast build times of Parcel can save developers a lot of time, especially when working on large projects. Because Parcel is designed to be highly optimized and efficient, it can perform builds quickly, even when working with a large number of files. This means that developers can spend less time waiting for builds to complete and more time working on their code.

Automatic Asset Management: Asset management can be a time-consuming task, especially when dealing with a large number of images, fonts, and other files. With Parcel, asset management is handled automatically, meaning that developers don't need to worry about manually managing their assets. This can save a lot of time and effort, and can also help to ensure that assets are optimized for performance, improving the overall performance of the application.



‚ù§Ô∏èWhat is `.gitignore`? What should we add and not add into it?
üëâ.gitignore is a file used by the Git version control system to specify files and directories that should be ignored and not tracked by Git. When you create a new repository or add files to an existing repository, Git will automatically look for a .gitignore file in the root of the repository and use it to determine which files to ignore.

In general, you should add to .gitignore any files or directories that are generated by your code or are not necessary for the development or production of your application. This can include log files, compiled code, build artifacts, and files that contain sensitive information, such as passwords or API keys.

Some common examples of files or directories that should be added to .gitignore are:

Log files
Compiled code
Build artifacts, such as node_modules or dist
Temporary files, such as .DS_Store on macOS
Editor-specific files, such as .vscode or .idea
Configuration files that contain sensitive information, such as .env or config.js
On the other hand, you should not add to .gitignore any files or directories that are necessary for the development or production of your application, or that contain source code that you want to track with Git. This can include source code files, configuration files that do not contain sensitive information, and files that are required for the application to run.

In general, it's a good practice to review your .gitignore file regularly and make sure that it includes all the files and directories that should be ignored, and that it does not include any files or directories that should be tracked by Git. This can help to keep your repository clean and organized, and can prevent unnecessary files from being committed and pushed to the repository.



‚ù§Ô∏èWhat is the difference between `package.json` and `package-lock.json`?
üëâpackage.json and package-lock.json are two files used by the npm package manager to manage dependencies in a Node.js project. While they may seem similar at first glance, there are some important differences between the two.

package.json is the main configuration file for an npm project. It contains metadata about the project, such as the name, version, author, and license, as well as a list of dependencies that the project relies on. The dependencies listed in package.json are typically grouped into two categories: dependencies and devDependencies. dependencies are the packages that are required to run the project in production, while devDependencies are packages that are only needed for development and testing.

package-lock.json is a file that is automatically generated by npm when you install or update a package. It contains a complete list of all the packages and their dependencies, along with their version numbers and installation paths. This file is used by npm to ensure that the same versions of packages are installed on every machine that runs the project, regardless of when they were installed. This can help to prevent issues with dependency conflicts or version mismatches.

In summary, package.json is the main configuration file for an npm project, while package-lock.json is an automatically generated file that contains a complete list of all the packages and their dependencies, along with their version numbers and installation paths. While both files are important for managing dependencies in an npm project, they serve different purposes and should not be confused with each other.



‚ù§Ô∏èWhy should I not modify `package-lock.json`?
üëâpackage-lock.json is an automatically generated file that is used by the npm package manager to ensure that the same versions of packages are installed on every machine that runs the project, regardless of when they were installed. This file contains a complete list of all the packages and their dependencies, along with their version numbers and installation paths.

It is generally not recommended to modify package-lock.json directly because it can lead to issues with dependency conflicts or version mismatches. If you need to update a package or its dependencies, you should use the npm install or npm update commands, which will automatically update package-lock.json for you.

When you run npm install or npm update, npm will compare the packages and dependencies listed in package.json with the ones listed in package-lock.json, and will make sure that the correct versions are installed based on the information in the lock file. If you modify package-lock.json directly, you may cause conflicts between the versions listed in package.json and the ones listed in package-lock.json, which can lead to unpredictable behavior or errors in your project.

In summary, modifying package-lock.json directly can cause issues with dependency conflicts or version mismatches, and should be avoided. Instead, use the npm install or npm update commands to update packages and their dependencies, and let npm handle the generation and management of package-lock.json for you.



‚ù§Ô∏èWhat is `node_modules` ? Is it a good idea to push that on git?
üëânode_modules is a directory that is created by the Node.js package manager (npm) when you install packages for your project. It contains all of the dependencies that your project needs in order to run. Each package is installed in its own subdirectory within node_modules.

It is generally not a good idea to push the node_modules directory to a Git repository for a few reasons:

It can be large: Depending on the number and size of the packages you have installed, the node_modules directory can be quite large, often several hundred megabytes or more. This can make it difficult to share or collaborate on your project, particularly if you have limited storage or bandwidth.

It is unnecessary: The node_modules directory is automatically generated by npm when you install packages for your project. As long as you have a package.json file that lists your dependencies, you can easily recreate the node_modules directory on any machine using the npm install command.

It can cause conflicts: If you push the node_modules directory to a Git repository, you may run into conflicts when different developers have different versions of the same package installed. This can lead to errors or unexpected behavior in your project.

For these reasons, it is generally recommended to add the node_modules directory to your .gitignore file so that it is not included in your Git repository. This will keep your repository smaller, make it easier to share and collaborate on your project, and help avoid conflicts or errors caused by different package versions.



‚ù§Ô∏èWhat is the `dist` folder?
üëâThe dist folder is short for "distribution", and it typically contains the production-ready version of your project, after it has been built and optimized for deployment. The contents of the dist folder are often the files that are actually deployed to a web server or hosting service to make your website or web application available to users.

The dist folder usually contains a compiled and/or minified version of your project's HTML, CSS, and JavaScript files, along with any images or other assets that are needed to run the application. Depending on the build process that you are using, the contents of the dist folder may be automatically generated from the files in your src folder, or they may be manually copied or moved into the dist folder.

Some of the benefits of having a separate dist folder for your production-ready code include:

Faster page load times: By minifying and compressing your code and assets, you can reduce the amount of data that needs to be downloaded by the user's browser, leading to faster page load times and a better user experience.

Improved security: By removing comments and other unnecessary information from your code, you can reduce the risk of exposing sensitive information or vulnerabilities that could be exploited by attackers.

Easier deployment: By having a separate folder that contains only the necessary files for your application to run, it can be easier to deploy and manage your application on a web server or hosting service.

In summary, the dist folder is typically used to store the production-ready version of your project after it has been built and optimized for deployment, and it often contains the files that are actually deployed to a web server or hosting service to make your website or web application available to users.



‚ù§Ô∏èWhat is `browserlists`?
üëâbrowserslist is a tool and library that is used to define the list of target browsers and environments that a project supports. It is often used as a configuration option for tools like autoprefixer, babel, and postcss to automatically generate CSS and JavaScript code that is compatible with the specified browsers and environments.

The browserslist configuration can be specified in a number of ways, including:

In the browserslist key of the package.json file
In a separate .browserslistrc configuration file
As an option when running a tool that supports browserslist configuration
The configuration itself is a comma-separated list of browser queries, each of which represents a target environment or set of browsers that the project should support. Each query can include a range of versions or a specific version number, as well as additional options like usage statistics, platform or operating system versions, or custom user agents.

Some examples of browserslist queries might include:

last 2 versions: The last two versions of all major browsers
ie >= 11: Internet Explorer 11 and higher
iOS >= 9: iOS 9 and higher
not dead: All currently maintained browsers
By using browserslist to define the target browsers and environments for a project, developers can ensure that their code is optimized for the widest possible audience, while still taking advantage of the latest and greatest features and functionality available in modern browsers.



‚ù§Ô∏èRead about dif bundlers: vite, webpack, parcel !
üëâvite, webpack, and parcel are all tools for building and bundling JavaScript applications, but they differ in their approach and features.

vite: vite is a relatively new build tool that is designed to be fast and flexible, with a focus on speed and developer experience. It is specifically optimized for building modern web applications with frameworks like React, Vue, and Svelte, and it uses native browser ES modules to deliver fast, incremental builds and a fast development server that supports hot module replacement. It also supports a variety of other features, like TypeScript support, CSS pre-processing, and static site generation.

webpack: webpack is a highly configurable build tool that is widely used in the JavaScript ecosystem. It is designed to be highly modular and flexible, with support for a wide range of features like code splitting, tree shaking, and advanced configuration options. webpack is often used to build large-scale web applications, and it is highly extensible, with a large ecosystem of plugins and loaders that can be used to customize its behavior.

parcel: parcel is a simple and fast build tool that is designed to be easy to use, with a focus on zero configuration and a quick start-up time. It is highly modular, with support for a wide range of file types and built-in support for features like CSS and JavaScript bundling, image optimization, and more. parcel is often used for small- to medium-sized projects, or for prototyping and experimentation, and it is known for its simplicity and ease of use.

Ultimately, the choice between vite, webpack, and parcel will depend on your specific needs and preferences, as well as the requirements of your project. Each tool has its own strengths and weaknesses, and the best choice will depend on factors like the size and complexity of your project, the features you need, and the development experience you want to create.




‚ù§Ô∏èRead about: ^ - caret and ~ - tilda
üëâIn npm, the ^ (caret) and ~ (tilde) characters are used as part of semantic versioning (semver) to specify ranges of versions for dependencies.

^ (Caret): The caret operator is used to specify a range of compatible versions where the left-most non-zero digit in the version number is fixed. For example, ^1.2.3 would allow any version from 1.2.3 up to, but not including, 2.0.0. If the major version number is zero, however, then the caret operator works differently: ^0.2.3 would allow any version from 0.2.3 up to, but not including, 0.3.0.

~ (Tilde): The tilde operator is used to specify a range of compatible versions where only the right-most digit can change. For example, ~1.2.3 would allow any version from 1.2.3 up to, but not including, 1.3.0. This is often used to indicate that a package is compatible with patch-level changes, but not with major or minor version changes.

Both the caret and tilde operators are used to specify a range of versions for a dependency, but they work slightly differently. The caret operator is more flexible and can allow for major version changes, while the tilde operator is more restrictive and only allows for patch-level changes.

It's worth noting that while the caret and tilde operators are useful for specifying ranges of compatible versions, they can also introduce some degree of unpredictability into a project's dependencies. For this reason, it's generally a good practice to use exact version numbers (e.g. 1.2.3) wherever possible, or to use a lockfile (like package-lock.json) to ensure that exact versions are installed.




‚ù§Ô∏èRead about Script types in html (MDN Docs)
üëâIn HTML, scripts are used to provide dynamic behavior and interactivity to web pages. The <script> element is used to define scripts, and it can have a type attribute that specifies the scripting language being used.

There are several types of scripts that can be used in HTML:

text/javascript: This is the default type for scripts in HTML, and it is used for JavaScript code.

text/ecmascript: This type is used for scripts written in ECMAScript, which is the language standard on which JavaScript is based.

application/javascript: This type is used for scripts that are delivered as standalone files, rather than being embedded in an HTML document.

application/ecmascript: This type is used for scripts written in ECMAScript that are delivered as standalone files.

module: This type is used for JavaScript modules, which are a new feature in modern JavaScript that allow for modular code organization and importing/exporting of code between files. This type of script is loaded asynchronously and cannot access the global scope of the HTML document.

It's worth noting that the type attribute is not required in HTML5, as the default is text/javascript. However, it's still a good practice to include it for clarity and compatibility with older browsers.

When using scripts in HTML, it's important to consider security implications, as scripts can potentially introduce vulnerabilities or expose sensitive information. It's generally recommended to avoid executing untrusted scripts, and to use content security policies (CSPs) to restrict the sources from which scripts can be loaded.
